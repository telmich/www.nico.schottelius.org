/* 
 * cinit
 * (c) 2005 Nico Schottelius (nico-linux at schottelius.org)
 * handle client requests
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>

#include "cinit.h"

/***********************************************************************
 * sigio: client handling
 */

/* we are called, if one or _more_ connections are waiting */
void sigio(int signal)
{
   struct ucred   suck;
   int            len, lens, nsock;
   struct         sockaddr_un sun;
   char           buf;

   D_PRINTF("sigio() startet");
   
   do {
      nsock = accept(sock,(struct sockaddr *) NULL, (socklen_t *) NULL);
   
      if( nsock == -1) {
         if (errno != EAGAIN) {
            perror("accept");
            _exit(1);
         } else {
            break;
         }
      }

      //getsockopt(s_tmp[s_idx], SOL_SOCKET, SO_PEERCRED, &suck, &len);
      getsockopt(nsock, SOL_SOCKET, SO_PEERCRED, &suck, &len);
      printf("angreifer: pid: %d uid: %d gid: %d\n",suck.pid,suck.uid,suck.gid);
   

      read(nsock,&buf,1);

      printf("command: %d\n",buf);

      while ( (len = read(nsock,&buf,1)) )  {
//         printf("laenge: %d\n",len);
         if(len == -1) {
//            if(errno != EINVAL && errno != EAGAIN) {
               perror("read");
               return;
//               _exit(1);
//            }
         }
         if(buf == 0) break;
         write(1,&buf,1);
      }
      printf("Fertig mit lesen\n");

      write(nsock,"ok\n",4);
      printf("fertig mit schreiben\n");
   } while ( 1 );

   printf("keine sockets mehr da..., sigio beendet sich jetzt.\n");
}


