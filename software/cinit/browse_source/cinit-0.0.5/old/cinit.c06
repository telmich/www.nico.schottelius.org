/* 
 * (c) 2005 Nico Schottelius (nico-linux at schottelius.org)
 * cinit.c
 * part of cLinux/cinit
 */

/* *stat() */
#include <sys/stat.h>
#include <unistd.h>

/* open */
#include <fcntl.h>

/* siggnal */
#include <signal.h>

/* PATH_MAX */
#include <limits.h>

/* printf() */
//#include <stdio.h>

/* str* */
#include <string.h>

/* sockets */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <errno.h>


#include "cinit.h"

/* global variable */
struct svcl svc_list;
int sock;

/***********************************************************************
 * sigio: client handling
 */

/* we are called, if one or _more_ connections are waiting */
void sigio(int signal)
{
   struct ucred suck;
   int len = sizeof(suck), lens;
   int nsock;
   struct sockaddr_un sun;
   char buf;

   lens=sizeof(sun);
   memset(&sun,0,lens);
   
/* this is always us! */
//   getsockopt(sock, SOL_SOCKET, SO_PEERCRED, &suck, &len);
//   printf("orig angreifer: pid: %d uid: %d gid: %d\n",suck.pid,suck.uid,suck.gid);

   do {
      //s_tmp[s_idx] = accept(sock,(struct sockaddr *) &sun, (socklen_t *) &lens);
      nsock = accept(sock,(struct sockaddr *) NULL, (socklen_t *) NULL);
   
   //   nsock = accept(sock,(struct sockaddr *) &sun, (socklen_t *) &lens);
//      if( s_tmp[s_idx] == -1) {
      if( nsock == -1) {
         if (errno != EAGAIN) {
            perror("accept");
            _exit(1);
         } else {
            break;
         }
      }

      //getsockopt(s_tmp[s_idx], SOL_SOCKET, SO_PEERCRED, &suck, &len);
      getsockopt(nsock, SOL_SOCKET, SO_PEERCRED, &suck, &len);
      printf("angreifer: pid: %d uid: %d gid: %d\n",suck.pid,suck.uid,suck.gid);
   

      read(nsock,&buf,1);

      printf("command: %d\n",buf);

      while ( (len = read(nsock,&buf,1)) )  {
//         printf("laenge: %d\n",len);
         if(len == -1) {
//            if(errno != EINVAL && errno != EAGAIN) {
               perror("read");
               return;
//               _exit(1);
//            }
         }
         if(buf == 0) break;
         write(1,&buf,1);
      }
      printf("Fertig mit lesen\n");

      write(nsock,"ok\n",4);
      printf("fertig mit schreiben\n");
   } while ( 1 );

   printf("keine sockets mehr da..., sigio beendet sich jetzt.\n");
}

/***********************************************************************
 * the main procedure
 */

int main()
{
   struct stat sbuf;
   int i;

   struct sigaction sa;

   /* signal handlers to ignore */
   sa.sa_handler=SIG_IGN;
//   sigaction(SIGINT,&sa,NULL);   /* ignore ctr+c */
   sigaction(SIGSTOP,&sa,NULL);   /* ignore ctr+z, stop */
   sigaction(SIGPIPE,&sa,NULL);   /* what todo when pipe/fifo closed */
   sigaction(SIGCHLD,&sa,NULL);   /* what todo when child exited */

   sa.sa_handler=sigio;
   sigaction(SIGIO,&sa,NULL);    /* what todo when data arrived on socket */

   D_PRINTF(CINIT_INIT);

   /* stat, checkdir */
   if( stat(CINIT_INIT,&sbuf) ) {
      cerr("PANIC ACTION: init dir missing", RT_PAR_FAIL);
   } else if( ! S_ISDIR(sbuf.st_mode) ) {
      cerr("PANIC ACTION: init is not a dir", RT_PAR_FAIL);
   }

   if( chdir(CINIT_INIT) == -1)
      cerr("PANIC ACTION: chdir to /etc/cinit/init failed!",RT_PAR_FAIL);

   /* count of started processes */
   svc_list.process = 0; 

   /* initial run, only if we are 'real' init' */
//   if( getpid() == 1) {
      i = run_init_svc();
      printf("Initialer Start rueckgabe: %d\n", i);
//   }

   /* signal handlers to do special things with */
   // something else sa.sa_handler=SIG_IGN;
//   sigaction(SIGUSR1,&sa,NULL);   /* reboot on sigusr1 */
//   sigaction(SIGUSR1,&sa,NULL);   /* power-off on sigusr2 */
//   sigaction(SIGTERM,&sa,NULL);   /* halt on sigterm */

   /* the main loop */
   while(1) ;

}
